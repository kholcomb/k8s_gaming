# ðŸ’¡ HINT 3: Complete Solution

## The Complete Fix

Here's the corrected SecurityContext configuration:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-app
  namespace: k8squest
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 8080  # Non-privileged port
    securityContext:
      runAsNonRoot: true  # âœ… Enforce non-root requirement
      runAsUser: 1000  # âœ… Run as UID 1000 (non-root)
      allowPrivilegeEscalation: false  # âœ… Prevent privilege escalation
      capabilities:
        drop:
        - ALL  # âœ… Drop all capabilities (best practice)
```

## What Each Field Does

### runAsNonRoot: true
- Kubernetes validates container doesn't run as root
- Acts as a safety check
- Required by many security policies

### runAsUser: 1000
- Container runs as user ID 1000
- Any non-zero UID works (1000 is conventional)
- Overrides image's default user (usually root)

### allowPrivilegeEscalation: false
- Prevents process from gaining more privileges
- Blocks setuid binaries
- Critical security hardening

### capabilities.drop: ALL
- Removes all Linux capabilities
- Minimal permissions
- Add back only what's needed (we don't need any)

## Why Port 8080 Instead of 80?

Ports below 1024 are "privileged ports" - only root can bind to them.

Since we're running as non-root user:
- Port 80 would fail (permission denied)
- Port 8080 works (non-privileged)

## Applying the Fix

```bash
# Apply the corrected configuration
kubectl apply -f solution.yaml

# Verify pod is running
kubectl get pod web-app -n k8squest

# Check what user it's running as
kubectl exec web-app -n k8squest -- id
# Should show: uid=1000 gid=0

# Check security context was applied
kubectl get pod web-app -n k8squest -o jsonpath='{.spec.containers[0].securityContext}' | jq
```

## Verification

The pod should now:
1. âœ… Start successfully
2. âœ… Run as UID 1000 (non-root)
3. âœ… Have privilege escalation disabled
4. âœ… Have minimal capabilities
5. âœ… Pass all security checks

## Alternative: Using fsGroup

If your application needs to access files, you might also need:

```yaml
spec:
  securityContext:  # Pod-level
    fsGroup: 2000  # Files owned by group 2000
  containers:
  - name: nginx
    securityContext:  # Container-level
      runAsUser: 1000
      runAsGroup: 2000
```

This ensures file permissions work correctly.

## Security Best Practices Applied

1. âœ… **Non-root user** - Limits blast radius
2. âœ… **No privilege escalation** - Prevents gaining root
3. âœ… **Dropped capabilities** - Minimal permissions
4. âœ… **Non-privileged port** - Can't bind to system ports
5. âœ… **Explicit user ID** - No defaults, no surprises

---

**Run the validation script** to verify everything is configured correctly!

```bash
./validate.sh
```
